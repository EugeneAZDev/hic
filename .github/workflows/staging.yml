name: Update Staging

on:
  push:
    branches: [main]

env:
  REGISTRY: ghcr.io

jobs:
  build-push:
    runs-on: ubuntu-latest
    environment: staging
    permissions:
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma client
        run: pnpm prisma:generate

      - name: Build applications
        run: |
          export NEXT_PUBLIC_BFF_URL=${{ vars.STAGING_NEXT_PUBLIC_BFF_URL }}
          export NEXT_PUBLIC_AUTH_SERVICE_URL=${{ vars.STAGING_NEXT_PUBLIC_AUTH_SERVICE_URL }}
          echo "NEXT_PUBLIC_BFF_URL: $NEXT_PUBLIC_BFF_URL"
          echo "NEXT_PUBLIC_AUTH_SERVICE_URL: $NEXT_PUBLIC_AUTH_SERVICE_URL"
          pnpm build

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker
          install: true

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set lowercase repository name
        run: |
          echo "REPO_OWNER_LOWER=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV
          echo "REPO_NAME_LOWER=$(echo '${{ github.event.repository.name }}' | \
            tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Export variables to environment
        run: |
          echo "STAGING_NEXT_PUBLIC_BFF_URL=${{ vars.STAGING_NEXT_PUBLIC_BFF_URL }}" >> $GITHUB_ENV
          echo "STAGING_NEXT_PUBLIC_AUTH_SERVICE_URL=${{ vars.STAGING_NEXT_PUBLIC_AUTH_SERVICE_URL }}" >> $GITHUB_ENV
          echo "STAGING_FRONTEND_URL=${{ vars.STAGING_FRONTEND_URL }}" >> $GITHUB_ENV

      - name: Show exported values (hex dump)
        run: |
          echo "BFF_URL hex:"
          printf '%s' "${{ env.STAGING_NEXT_PUBLIC_BFF_URL }}" | xxd

      - name: Debug environment variables
        run: |
          echo "STAGING_NEXT_PUBLIC_BFF_URL: ${{ env.STAGING_NEXT_PUBLIC_BFF_URL }}"
          echo "STAGING_NEXT_PUBLIC_AUTH_SERVICE_URL: ${{ env.STAGING_NEXT_PUBLIC_AUTH_SERVICE_URL }}"
          echo "STAGING_FRONTEND_URL: ${{ env.STAGING_FRONTEND_URL }}"

      - name: Build shared base image
        uses: docker/bake-action@v5
        with:
          files: ./docker-bake.hcl
          targets: shared
          set: |
            *.tags=ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/shared:staging-latest
            *.args.NODE_ENV=production
            *.args.NEXT_PUBLIC_BFF_URL=${{ env.STAGING_NEXT_PUBLIC_BFF_URL }}
            *.args.NEXT_PUBLIC_AUTH_SERVICE_URL=${{ env.STAGING_NEXT_PUBLIC_AUTH_SERVICE_URL }}
            *.args.FRONTEND_URL=${{ env.STAGING_FRONTEND_URL }}
            *.output=type=docker
            *.load=true

      - name: Push shared base image
        run: |
          docker push ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/shared:staging-latest

      - name: Build application images
        uses: docker/bake-action@v5
        with:
          files: ./docker-bake.hcl
          targets: frontend,backend,bff,auth-service,worker-service
          set: |
            *.no-cache=true
            *.output=type=docker
            *.load=true
            frontend.tags=ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/frontend:staging-latest
            backend.tags=ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/backend:staging-latest
            bff.tags=ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/bff:staging-latest
            auth-service.tags=ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/auth-service:staging-latest
            worker-service.tags=ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/worker-service:staging-latest

      - name: Push application images
        run: |
          docker push ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/frontend:staging-latest
          docker push ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/backend:staging-latest
          docker push ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/bff:staging-latest
          docker push ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/auth-service:staging-latest
          docker push ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/worker-service:staging-latest

      - name: Build nginx image
        uses: docker/bake-action@v5
        with:
          files: ./docker-bake.hcl
          targets: nginx
          set: |
            *.tags=ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/nginx:staging-latest
            *.output=type=docker
            *.load=true

      - name: Push nginx image
        run: |
          docker push ghcr.io/${{ env.REPO_OWNER_LOWER }}/${{ env.REPO_NAME_LOWER }}/nginx:staging-latest
        env:
          # Provide dummy values for build-time variables
          JWT_SECRET: "dummy-build-secret"
          DB_USER: "dummy"
          DB_PASSWORD: "dummy"
          DB_NAME: "dummy"
          AUTH_DB_USER: "dummy"
          AUTH_DB_PASSWORD: "dummy"
          AUTH_DB_NAME: "dummy"
          FRONTEND_URL: "dummy"
          NEXT_PUBLIC_BFF_URL: "dummy"
          NEXT_PUBLIC_AUTH_SERVICE_URL: "dummy"
          DOMAIN: "localhost"
          SSL_ENABLED: "false"
          REGISTRY_URL: "ghcr.io/dummy"
          VERSION: "staging-latest"

  deploy:
    needs: build-push
    runs-on: [self-hosted, staging, production]
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # - name: Staging server cleanup (specific)
      #   run: |
      #     cd /opt/actions-runner/_work/hic/hic
          
      #     # Stop staging services
      #     docker compose -f infra/docker-compose/base.yaml \
      #                    -f infra/docker-compose/staging.yaml \
      #                    -f infra/docker-compose/nginx.yaml \
      #                    --env-file .env \
      #                    --profile staging down || true
          
      #     # Aggressive cleanup
      #     docker system prune -af && docker volume prune -f && docker builder prune -af

      - name: Clean up before deploy
        run: |
          # Set required environment variables for docker-compose
          export JWT_SECRET=${{ secrets.STAGING_JWT_SECRET || 'dummy_jwt_secret_for_staging' }}
          export DB_USER=${{ vars.STAGING_DB_USER || 'hic_user' }}
          export DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD || 'dummy_password' }}
          export DB_NAME=${{ vars.STAGING_DB_NAME || 'hic_staging' }}
          export AUTH_DB_USER=${{ vars.STAGING_AUTH_DB_USER || 'hic_auth_user' }}
          export AUTH_DB_PASSWORD=${{ secrets.STAGING_AUTH_DB_PASSWORD || 'dummy_auth_password' }}
          export AUTH_DB_NAME=${{ vars.STAGING_AUTH_DB_NAME || 'hic_auth_staging' }}
          
          # Clean up build artifacts
          rm -rf .turbo || true
          rm -rf node_modules/.cache || true
          
          # Stop and remove existing containers
          docker compose -f infra/docker-compose/base.yaml \
                         -f infra/docker-compose/staging.yaml \
                         down --remove-orphans || true
          
          # Stop system web servers that might be using port 80
          sudo systemctl stop nginx || true
          sudo systemctl stop apache2 || true
          sudo systemctl stop httpd || true
          
          RUNNER_USER="runner"

          for port in 80 443 5001 3013 3014 3015 3001; do
            sudo lsof -ti:$port -sTCP:LISTEN 2>/dev/null | while read -r pid; do
              user=$(ps -o user= -p "$pid" 2>/dev/null || true)
              if [[ -n $pid && $user != "$RUNNER_USER" ]]; then
                echo "Killing $pid (user=$user) on port $port"
                sudo kill -9 "$pid" 2>/dev/null || true
              fi
            done
          done
          
          # Remove only staging nginx containers (not all nginx images)
          docker rm -f $(docker ps -aq --filter "name=hic-nginx-staging") || true
          
          # Clean up only unused Docker resources (preserve registry images)
          docker system prune -f
          
          # Wait a moment for ports to be released
          sleep 10
          
          # Verify ports are free
          echo "Checking if ports are free:"
          sudo ss -tlnp | grep -E "(80|443|5001|3013|3014|3015|3001)" || echo "All ports are free"

      # ========================================
      # MEMORY CLEANUP FOR WEAK SERVERS
      # ========================================
      # Uncomment the following section if your server has limited memory
      # and you're experiencing OOM (Out of Memory) issues during deployment
      # Create 2GB swap file on weak servers:
      # sudo fallocate -l 2G /swapfile
      # sudo chmod 600 /swapfile
      # sudo mkswap /swapfile
      # sudo swapon /swapfile
      # echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
      # ========================================
      - name: Aggressive memory cleanup (for weak servers)
        run: |
          echo "Performing aggressive memory cleanup for weak server..."
          
          # Stop ALL Docker containers (not just staging)
          echo "Stopping all Docker containers..."
          docker stop $(docker ps -aq) 2>/dev/null || true
          
          # Remove ALL stopped containers
          echo "Removing all stopped containers..."
          docker rm $(docker ps -aq) 2>/dev/null || true
          
          # Remove unused images (except registry images)
          echo "Removing unused images..."
          docker image prune -af --filter "until=24h" || true
          
          # Remove unused volumes
          echo "Removing unused volumes..."
          docker volume prune -f || true
          
          # Remove unused networks
          echo "Removing unused networks..."
          docker network prune -f || true
          
          # Clear Docker build cache
          echo "Clearing Docker build cache..."
          docker builder prune -af || true
          
          # Force garbage collection
          echo "Forcing garbage collection..."
          sync
          echo 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null || true
          
          # Show memory usage
          echo "Memory usage after cleanup:"
          free -h
          docker system df
          
          # Wait for memory to be freed
          sleep 30
      # ========================================
      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'pnpm'

      - name: Deploy to staging
        run: |
          # Set environment variables for staging
          export REGISTRY_URL=${{ env.REGISTRY }}/$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')
          export VERSION=staging-latest
          
          # Create staging env file from variables and secrets
          echo "Creating .env file with staging variables..."
          cat > /opt/actions-runner/_work/hic/hic/.env << EOF
          APP_ENV=${{ vars.STAGING_APP_ENV || 'staging' }}
          REGISTRY_URL=${{ vars.STAGING_REGISTRY_URL || 'ghcr.io/eugeneazdev/hic' }}
          VERSION=${{ vars.STAGING_VERSION || 'staging-latest' }}
          DB_NAME=${{ vars.STAGING_DB_NAME || 'hic_staging' }}
          DB_USER=${{ vars.STAGING_DB_USER || 'hic_user' }}
          DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD || 'dummy_password' }}
          AUTH_DB_NAME=${{ vars.STAGING_AUTH_DB_NAME || 'hic_auth_staging' }}
          AUTH_DB_USER=${{ vars.STAGING_AUTH_DB_USER || 'hic_auth_user' }}
          AUTH_DB_PASSWORD=${{ secrets.STAGING_AUTH_DB_PASSWORD || 'dummy_auth_password' }}
          JWT_SECRET=${{ secrets.STAGING_JWT_SECRET || 'dummy_jwt_secret_for_staging' }}
          FRONTEND_URL=${{ vars.STAGING_FRONTEND_URL || 'https://hic-staging.gtechdev.top' }}
          NEXT_PUBLIC_BFF_URL=${{ vars.STAGING_NEXT_PUBLIC_BFF_URL || 'https://hic-staging.gtechdev.top/bff' }}
          NEXT_PUBLIC_AUTH_SERVICE_URL=${{ vars.STAGING_NEXT_PUBLIC_AUTH_SERVICE_URL || 'https://hic-staging.gtechdev.top/bff/auth' }}
          DOMAIN=${{ vars.STAGING_DOMAIN || 'hic-staging' }}
          SSL_ENABLED=${{ vars.STAGING_SSL_ENABLED || 'true' }}
          NGINX_HTTP_PORT=80
          NGINX_HTTPS_PORT=443
          EOF
          
          # Debug: Show .env file content (without secrets)
          echo "Created .env file:"
          cat /opt/actions-runner/_work/hic/hic/.env | sed 's/PASSWORD=.*/PASSWORD=***/' | sed 's/SECRET=.*/SECRET=***/'
          
          # Export environment variables for database operations
          source .env
          
          # Pull latest images (including nginx from registry)
          docker compose -f infra/docker-compose/base.yaml \
                         -f infra/docker-compose/staging.yaml \
                         -f infra/docker-compose/nginx.yaml \
                         --env-file .env \
                         --profile staging \
                         pull --ignore-pull-failures
          
          # Verify nginx image is correct
          echo "Verifying nginx image..."
          docker inspect ${REGISTRY_URL}/nginx:staging-latest | \
            grep -E "(WorkingDir|Entrypoint|Cmd)" || echo "Nginx image verification failed"
          
          # Initialize databases
          echo "Initializing databases..."
          docker compose -f infra/docker-compose/base.yaml \
                         -f infra/docker-compose/staging.yaml \
                         --env-file .env \
                         --profile staging \
                         up -d db auth-db
          
          # Wait for databases to be ready
          echo "Waiting for databases to be ready..."
          sleep 30
          
          # Install database extensions
          echo "Installing database extensions..."
          docker exec hic-db-basic psql -U "${DB_USER}" -d "${DB_NAME}" \
            -c "CREATE EXTENSION IF NOT EXISTS \"citext\"; CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";" || true
          docker exec hic-auth-db-basic psql -U "${AUTH_DB_USER}" -d "${AUTH_DB_NAME}" \
            -c "CREATE EXTENSION IF NOT EXISTS \"citext\"; CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";" || true
          
          # Run Prisma migrations (idempotent)
          echo "Running Prisma migrations..."
          pnpm install
          
          # Check if migrations are needed
          echo "Checking migration status..."
          echo "Testing main DB connection..."
          MAIN_DB_STATUS=$(DATABASE_URL="postgresql://${DB_USER}:${DB_PASSWORD}@localhost:5435/${DB_NAME}" \
            pnpm --filter ./packages/prisma/main prisma migrate status 2>&1) || echo "Main DB status check failed"
          echo "Testing auth DB connection..."
          AUTH_DB_STATUS=$(DATABASE_URL_AUTH="postgresql://${AUTH_DB_USER}:${AUTH_DB_PASSWORD}@localhost:5437/${AUTH_DB_NAME}" \
            pnpm --filter ./packages/prisma/auth prisma migrate status 2>&1) || echo "Auth DB status check failed"
          
          echo "Main DB migration status: $MAIN_DB_STATUS"
          echo "Auth DB migration status: $AUTH_DB_STATUS"
          
          # Check if migrations failed (ignore "not yet applied" messages)
          if [[ "$MAIN_DB_STATUS" == *"failed"* ]] || [[ "$AUTH_DB_STATUS" == *"failed"* ]] || [[ "$MAIN_DB_STATUS" == *"Error:"* ]] || [[ "$AUTH_DB_STATUS" == *"Error:"* ]]; then
            echo "❌ Migration status check failed!"
            echo "Main DB status: $MAIN_DB_STATUS"
            echo "Auth DB status: $AUTH_DB_STATUS"
            echo "Stopping deployment due to migration errors..."
            exit 1
          fi
          
          # Apply migrations (only new ones)
          echo "Applying migrations..."
          echo "Applying main DB migrations..."
          MAIN_DB_MIGRATE=$(DATABASE_URL="postgresql://${DB_USER}:${DB_PASSWORD}@localhost:5435/${DB_NAME}" \
            pnpm --filter ./packages/prisma/main prisma migrate deploy 2>&1) || echo "Main DB migration failed"
          echo "Applying auth DB migrations..."
          AUTH_DB_MIGRATE=$(DATABASE_URL_AUTH="postgresql://${AUTH_DB_USER}:${AUTH_DB_PASSWORD}@localhost:5437/${AUTH_DB_NAME}" \
            pnpm --filter ./packages/prisma/auth prisma migrate deploy 2>&1) || echo "Auth DB migration failed"
          
          echo "Main DB migration result: $MAIN_DB_MIGRATE"
          echo "Auth DB migration result: $AUTH_DB_MIGRATE"
          
          # Check if migrations failed (ignore "not yet applied" messages)
          if [[ "$MAIN_DB_MIGRATE" == *"failed"* ]] || [[ "$AUTH_DB_MIGRATE" == *"failed"* ]] || [[ "$MAIN_DB_MIGRATE" == *"Error:"* ]] || [[ "$AUTH_DB_MIGRATE" == *"Error:"* ]]; then
            echo "❌ Migration deployment failed!"
            echo "Main DB migration result: $MAIN_DB_MIGRATE"
            echo "Auth DB migration result: $AUTH_DB_MIGRATE"
            echo "Stopping deployment due to migration errors..."
            exit 1
          fi
          
          # Generate clients (idempotent)
          echo "Generating Prisma clients..."
          DATABASE_URL="postgresql://${DB_USER}:${DB_PASSWORD}@localhost:5435/${DB_NAME}" \
            pnpm --filter ./packages/prisma/main prisma generate || echo "Main DB client generation failed"
          DATABASE_URL_AUTH="postgresql://${AUTH_DB_USER}:${AUTH_DB_PASSWORD}@localhost:5437/${AUTH_DB_NAME}" \
            pnpm --filter ./packages/prisma/auth prisma generate || echo "Auth DB client generation failed"
          
          # Create symlinks for nginx volumes (if they don't exist)
          echo "Creating symlinks for nginx volumes..."
          mkdir -p infra/nginx/ssl infra/nginx/cert
          if [ ! -L infra/nginx/ssl ]; then
            ln -sf /opt/hic/infra/nginx/ssl infra/nginx/ssl
          fi
          if [ ! -L infra/nginx/cert ]; then
            ln -sf /opt/hic/infra/nginx/cert infra/nginx/cert
          fi
          
          # Deploy services
          docker compose -f infra/docker-compose/base.yaml \
                         -f infra/docker-compose/staging.yaml \
                         -f infra/docker-compose/nginx.yaml \
                         --env-file .env \
                         --profile staging \
                         up -d --remove-orphans

      - name: Health check
        run: |
          echo "Waiting for services to start..."
          sleep 30
          
          # Check if services are running
          docker compose -f infra/docker-compose/base.yaml \
                         -f infra/docker-compose/staging.yaml \
                         -f infra/docker-compose/nginx.yaml \
                         --env-file .env \
                         --profile staging \
                         ps
          
          # Check nginx configuration and logs
          echo "Checking nginx configuration..."
          docker exec hic-nginx-staging nginx -t || echo "Nginx configuration test failed"
          
          echo "Checking nginx logs..."
          docker logs hic-nginx-staging --tail 20
